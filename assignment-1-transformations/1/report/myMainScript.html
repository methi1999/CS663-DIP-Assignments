
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>myMainScript</title><meta name="generator" content="MATLAB 9.8"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-08-29"><meta name="DC.source" content="myMainScript.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Q1</a></li><li><a href="#2">Q1a</a></li><li><a href="#5">Q1b</a></li><li><a href="#7">Q1c</a></li><li><a href="#9">Q1d</a></li><li><a href="#11">Q1e</a></li><li><a href="#17">Q1f</a></li></ul></div><h2 id="1">Q1</h2><p>We keep the number of colours per intensity to be 200, as specified in the assignment submission instructions.</p><p>Throughout this question, we have used the following references:</p><p>1) MATLAB documentation: <a href="https://in.mathworks.com/help/matlab/examples.html?category=images_images">https://in.mathworks.com/help/matlab/examples.html?category=images_images</a></p><p>2) In specific, from MATLAB documentation we referred to various functions such as imagesc/imread and derivates, truesize and other image output controlling functions. We also used standard matlab functions such as imrotate to confirm the proper working of our codes as compared to the standard MATLAB implementations.</p><p>3) The following "Lectures on Image Processing" were helpful for us to understand a practical implementation of the various interpolation functions: <a href="https://ia802707.us.archive.org/23/items/Lectures_on_Image_Processing/EECE_4353_15_Resampling.pdf">https://ia802707.us.archive.org/23/items/Lectures_on_Image_Processing/EECE_4353_15_Resampling.pdf</a></p><h2 id="2">Q1a</h2><img vspace="5" hspace="5" src="myMainScript_01.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_02.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_03.png" alt=""> <h2 id="5">Q1b</h2><img vspace="5" hspace="5" src="myMainScript_04.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_05.png" alt=""> <h2 id="7">Q1c</h2><img vspace="5" hspace="5" src="myMainScript_06.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_07.png" alt=""> <h2 id="9">Q1d</h2><img vspace="5" hspace="5" src="myMainScript_08.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_09.png" alt=""> <h2 id="11">Q1e</h2><p>We show Barbara's face, smoothed using different methods. We observe from the results that bicubic and bilinear interpolation are clearly much better than nearest neighbor interpolation. This is also apparent from the resizing comparison in the previous subparts. The differences between Bilinear and Bicubic are subtle in this image, but bicubic stands out. This is more clearly seen on a grayscale image, which are shown in the previous subparts. On Comparison, it is clear that Bicubic interpolation performs better than Bilinear in practice.</p><p>This follows the expected results from interpolation theory - Bicubic is a 3rd degree polynomial approximation, thus it is able to capture more information of the image and smoothen out the image better. Bilinear interpolation is a linear approximation over the 2 dimensions. Nearest Neighbor is a zero-th order approximation over it's surroundings, and thus it performs significantly worse, while being the easiest to implement.</p><img vspace="5" hspace="5" src="myMainScript_10.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_11.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_12.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_13.png" alt=""> <h2 id="17">Q1f</h2><p>We pad the image so as to not lose information in the rotation.</p><img vspace="5" hspace="5" src="myMainScript_14.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_15.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Q1
% We keep the number of colours per intensity to be 200, as specified in
% the assignment submission instructions.
%
% Throughout this question, we have used the following references: 
%
% 1) MATLAB documentation: https://in.mathworks.com/help/matlab/examples.html?category=images_images
%
% 2) In specific, from MATLAB documentation we referred to various
% functions such as imagesc/imread and derivates, truesize and other image
% output controlling functions. We also used standard matlab functions such
% as imrotate to confirm the proper working of our codes as compared to the
% standard MATLAB implementations.
%
% 3) The following "Lectures on Image Processing" were helpful for us to understand
% a practical implementation of the various interpolation functions: 
% https://ia802707.us.archive.org/23/items/Lectures_on_Image_Processing/EECE_4353_15_Resampling.pdf

%keeping number of colours per intensity to be 200
myNumOfColors = 200;
myColorScale = [ [0:1/(myNumOfColors-1):1]' , ...
    [0:1/(myNumOfColors-1):1]' , [0:1/(myNumOfColors-1):1]' ];
tic;
%% Q1a
circle_concentric_1 = imread('../data/circles_concentric.png');

%shrink the image by different factors
circle_concentric_2 = myShrinkImageByFactorD(circle_concentric_1,2);
circle_concentric_3 = myShrinkImageByFactorD(circle_concentric_1,3);

%plot the images side-by-side
subplot(1,1,1), imagesc(circle_concentric_1);
daspect ([1 1 1]);
truesize([300 300]);
title('Original Image');
colorbar;
colormap (myColorScale);
colormap gray;
%%
subplot(1,1,1), imagesc(circle_concentric_2);
daspect ([1 1 1]);
truesize([300 300]);
title('Image with d = 2');
colorbar;
colormap (myColorScale);
colormap gray;
%%
subplot(1,1,1), imagesc(circle_concentric_3);
daspect ([1 1 1]);
truesize([300 300]);
title('Image with d = 3');
colorbar;
axis tight;
colormap (myColorScale);
colormap gray;
%% Q1b
bar = imread('../data/barbaraSmall.png');
bar = double(bar)/255;
[row_bar, col_bar] = size(bar);
output_dim = [row_bar*3-2, col_bar*2-1];

% phi_x[i][j], phi_y[i][j] represents where position (i,j) in output
% image comes from - value will be some real valued x and real valued y
% in the input image
[phi_y, phi_x] = meshgrid(1:output_dim(2),1:output_dim(1));

%make the correct phi_x, phi_y for resizing
phi_x = (phi_x + 2) / 3;
phi_y = (phi_y + 1) / 2;

%do the interpolation
biliterpbar = myBilinearInterpolation(bar, phi_x, phi_y);
axis tight;
colormap (myColorScale);
colormap gray;
subplot(1,1,1), imagesc(single(bar));
daspect ([1 1 1]);
truesize([300 300]);
title('Original Image');
colorbar
%%
subplot(1,1,1), imagesc(single(biliterpbar));
daspect ([103/307 103/205 1]);
truesize([300 300]);
title('Bilinear Interpolation');
colorbar

%% Q1c
NNiterpbar = myNearestNeighborInterpolation(bar, phi_x, phi_y);
axis tight;
colormap (myColorScale);
colormap gray;
subplot(1,1,1), imagesc(single(bar));
daspect ([1 1 1]);
colorbar
title('Original Image');
%%
subplot(1,1,1), imagesc(single(NNiterpbar)); % phantom is a popular test image
daspect ([103/307 103/205 1]);
title('Nearest Neighbor Interpolation');
colorbar

%% Q1d
bicubic_iterp_bar = myBicubicInterpolation(bar, phi_x, phi_y);
axis tight;
colormap (myColorScale);
colormap gray;
subplot(1,1,1), imagesc(single(bar));
daspect ([1 1 1]);
title('Original Image');
colorbar
%%
subplot(1,1,1), imagesc(single(bicubic_iterp_bar)); % phantom is a popular test image
daspect ([103/307 103/205 1]);
title('Bicubic Interpolation');
colorbar
%% Q1e
%%
% We show Barbara's face, smoothed using different methods. We
% observe from the results that bicubic and bilinear interpolation are
% clearly much better than nearest neighbor interpolation. This is also
% apparent from the resizing comparison in the previous subparts.
% The differences between Bilinear and Bicubic are subtle in this image, but
% bicubic stands out. This is more clearly seen on a grayscale image, which
% are shown in the previous subparts. On Comparison, it is clear that
% Bicubic interpolation performs better than Bilinear in practice.
%
% This follows the expected results from interpolation theory - Bicubic is a
% 3rd degree polynomial approximation, thus it is able to capture more
% information of the image and smoothen out the image better. Bilinear
% interpolation is a linear approximation over the 2 dimensions. Nearest
% Neighbor is a zero-th order approximation over it's surroundings, and thus
% it performs significantly worse, while being the easiest to implement.

%%
barbara_face = bar(1:70,34:103);

[face_phi_y, face_phi_x] = meshgrid(1:140,1:140);
face_phi_x = (face_phi_x + 1) / 2;
face_phi_y = (face_phi_y + 1) / 2;

barbara_face_NN = myNearestNeighborInterpolation(barbara_face, face_phi_x, face_phi_y);
barbara_face_bilinear = myBilinearInterpolation(barbara_face, face_phi_x, face_phi_y);
barbara_face_bicubic = myBicubicInterpolation(barbara_face, face_phi_x, face_phi_y);

axis tight;
colormap (myColorScale);
colormap jet;
subplot(1,1,1), imagesc(single(barbara_face)); % phantom is a popular test image
daspect ([1 1 1]);
title('Original Image');
colorbar
%%
subplot(1,1,1), imagesc(single(barbara_face_NN));
daspect ([1/2 1/2 1]);
title('Nearest Neighbor');
colorbar
%%
subplot(1,1,1), imagesc(single(barbara_face_bilinear));
daspect ([1/2 1/2 1]);
title('Bilinear');
colorbar
%%
subplot(1,1,1), imagesc(single(barbara_face_bicubic));
daspect ([1/2 1/2 1]);
title('Bicubic');
colorbar
%% Q1f
% We pad the image so as to not lose information in the rotation.
padded_bar = zeros(140,140);
padded_bar(20:122,20:122) = bar;
%This function takes anti-clockwise rotations as positive.
final = myImageRotation(padded_bar, -30);
axis tight;
colormap (myColorScale);
colormap gray;
subplot(1,1,1), imagesc(bar);
daspect ([1 1 1]);
title('Original Image');
colorbar
%%
subplot(1,1,1), imagesc(final);
daspect ([1 1 1]);
colormap (myColorScale);
colormap gray;
title('30 degree rotation');
colorbar
##### SOURCE END #####
--></body></html>