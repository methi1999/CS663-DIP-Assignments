
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>References &amp; Ideology</title><meta name="generator" content="MATLAB 9.8"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-09-28"><meta name="DC.source" content="myMainScript.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>References &amp; Ideology</h1><!--introduction--><p>We used the following references for this question:</p><p>1) The MATLAB documentation:</p><p><a href="https://in.mathworks.com/matlabcentral/answers/316163-how-to-get-pixelcount-in-image">https://in.mathworks.com/matlabcentral/answers/316163-how-to-get-pixelcount-in-image</a></p><p><a href="https://in.mathworks.com/matlabcentral/answers/13020-2d-gaussian-function">https://in.mathworks.com/matlabcentral/answers/13020-2d-gaussian-function</a></p><p><a href="https://www.mathworks.com/help/images/ref/nlfilter.html">https://www.mathworks.com/help/images/ref/nlfilter.html</a></p><p>In this question, we note that patch filtering has two tunable parameters in general: one of them is the <img src="myMainScript_eq12708923657795990387.png" alt="$\sigma_g$" style="width:14px;height:11px;"> parameter for the gaussian patch, and the other is the <img src="myMainScript_eq10122300864945678129.png" alt="$\sigma_w$" style="width:15px;height:9px;"> parameter for the window. Here, we set the <img src="myMainScript_eq12708923657795990387.png" alt="$\sigma_g$" style="width:14px;height:11px;"> parameter of the gaussian patch to be 1.5 (since the patch is 9*9, this is a reasonably small value of sigma that should work well).</p><p>Then, we tune the <img src="myMainScript_eq10122300864945678129.png" alt="$\sigma_w$" style="width:15px;height:9px;"> value of the window, which was asked in the question.</p><p>Although having implemented and tested it (about 4.2x faster), we decided not to use Gaussian blurring + Downsampling, since the quality degradation is observable. Since we had enough time for the assignment, we decided to use only the high quality outputs, thus keeping the RMSD values significantly lower than the downsampled output.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Q3a</a></li><li><a href="#7">Q3b</a></li><li><a href="#12">Q3c</a></li><li><a href="#17">Q3d</a></li></ul></div><h2 id="2">Q3a</h2><p>The optimal <img src="myMainScript_eq10122300864945678129.png" alt="$\sigma_w$" style="width:15px;height:9px;"> is 0.66</p><p>The RMSD for optimal <img src="myMainScript_eq10122300864945678129.png" alt="$\sigma_w$" style="width:15px;height:9px;"> is 2.5824</p><p>The RMSD for optimal <img src="myMainScript_eq10122300864945678129.png" alt="$\sigma_w$" style="width:15px;height:9px;"> * 0.9 is 2.6197</p><p>The RMSD for optimal <img src="myMainScript_eq10122300864945678129.png" alt="$\sigma_w$" style="width:15px;height:9px;"> * 1.1 is 2.6473</p><img vspace="5" hspace="5" src="myMainScript_01.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_02.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_03.png" alt=""> <h2 id="7">Q3b</h2><p>The optimal <img src="myMainScript_eq10122300864945678129.png" alt="$\sigma_w$" style="width:15px;height:9px;"> is 0.88</p><p>The RMSD for optimal <img src="myMainScript_eq10122300864945678129.png" alt="$\sigma_w$" style="width:15px;height:9px;"> is 3.8867</p><p>The RMSD for optimal <img src="myMainScript_eq10122300864945678129.png" alt="$\sigma_w$" style="width:15px;height:9px;"> * 0.9 is 3.9041</p><p>The RMSD for optimal <img src="myMainScript_eq10122300864945678129.png" alt="$\sigma_w$" style="width:15px;height:9px;"> * 1.1 is 3.9810</p><img vspace="5" hspace="5" src="myMainScript_04.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_05.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_06.png" alt=""> <h2 id="12">Q3c</h2><p>The optimal <img src="myMainScript_eq10122300864945678129.png" alt="$\sigma_w$" style="width:15px;height:9px;"> is 0.9</p><p>The RMSD for optimal <img src="myMainScript_eq10122300864945678129.png" alt="$\sigma_w$" style="width:15px;height:9px;"> is 3.9328</p><p>The RMSD for optimal <img src="myMainScript_eq10122300864945678129.png" alt="$\sigma_w$" style="width:15px;height:9px;"> * 0.9 is 3.9387</p><p>The RMSD for optimal <img src="myMainScript_eq10122300864945678129.png" alt="$\sigma_w$" style="width:15px;height:9px;"> * 1.1 is 4.0038</p><img vspace="5" hspace="5" src="myMainScript_07.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_08.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_09.png" alt=""> <h2 id="17">Q3d</h2><p>The intensity diagram for the isotropic gaussian patch is as follows</p><img vspace="5" hspace="5" src="myMainScript_10.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% References & Ideology
% We used the following references for this question:
%
% 1) The MATLAB documentation:
%
% https://in.mathworks.com/matlabcentral/answers/316163-how-to-get-pixelcount-in-image
%
% https://in.mathworks.com/matlabcentral/answers/13020-2d-gaussian-function
%
% https://www.mathworks.com/help/images/ref/nlfilter.html
% 
% In this question, we note that patch filtering has two tunable parameters
% in general: one of them is the $\sigma_g$ parameter for the gaussian patch,
% and the other is the $\sigma_w$ parameter for the window. Here, we set the
% $\sigma_g$ parameter of the gaussian patch to be 1.5 (since the patch is 9*9,
% this is a reasonably small value of sigma that should work well). 
%
% Then, we tune the $\sigma_w$ value of the window, which was asked in the
% question.
%
% Although having implemented and tested it (about 4.2x faster),
% we decided not to use Gaussian blurring + Downsampling, since the quality
% degradation is observable. Since we had enough time for the assignment,
% we decided to use only the high quality outputs, thus keeping the RMSD
% values significantly lower than the downsampled output.

%%
myNumOfColors = 200;
myColorScale = [ [0:1/(myNumOfColors-1):1]' , ...
    [0:1/(myNumOfColors-1):1]' , [0:1/(myNumOfColors-1):1]' ];
tic;
%% Q3a
% The optimal $\sigma_w$ is 0.66
%
% The RMSD for optimal $\sigma_w$ is 2.5824
%
% The RMSD for optimal $\sigma_w$ * 0.9 is 2.6197
%
% The RMSD for optimal $\sigma_w$ * 1.1 is 2.6473
%
%Since the images have been generated and stored in the images directory, 
%we will be directly loading the outputs and reporting them. 
%The original images can be recomputed by the code below.

first_im = load('../images/barbara_first.mat');
input_im = load('../images/barbara_input.mat');
output_im_sigma = load('../images/barbara_sigma.mat');
output_im_large_sigma = load('../images/barbara_large_sigma.mat');
output_im_small_sigma = load('../images/barbara_small_sigma.mat');

first_im = double(cell2mat(struct2cell(first_im)));
input_im = double(cell2mat(struct2cell(input_im)));
output_im_sigma = double(cell2mat(struct2cell(output_im_sigma)));
output_im_large_sigma = double(cell2mat(struct2cell(output_im_large_sigma)));
output_im_small_sigma = double(cell2mat(struct2cell(output_im_small_sigma)));

% images = {'../data/barbara.mat'};
% im = 1;
% path = images{im};
% input_im = load(path);
% input_im = cell2mat(struct2cell(input_im));
% input_im = double(input_im);
% first_im = input_im;
% spread = range(input_im,'all');
% rng(0);
% noise = (0.05*spread)*randn(size(input_im,1));
% input_im = input_im + noise;
% output_im_sigma = myPatchBasedFiltering(input_im, 0.66);
% output_im_small_sigma = myPatchBasedFiltering(input_im, 0.9 * 0.66);
% output_im_large_sigma = myPatchBasedFiltering(input_im, 1.1 * 0.66);
%%
imagesc(first_im);
daspect ([1 1 1]);
title('Original Image');
colorbar;
colormap (myColorScale);
colormap gray;
%%
imagesc(input_im);
daspect ([1 1 1]);
title('Corrupted Image');
colorbar;
colormap (myColorScale);
colormap gray;
%%
imagesc(output_im_sigma);
daspect ([1 1 1]);
title('Filtered Image');
colorbar;
colormap (myColorScale);
colormap gray;
%%
%ok
% diff = output_im_small_sigma - first_im;
% diff = diff .^ 2;
% diff = sum(diff, 'all');
% num_pixels = numel(first_im);
% RMSE = sqrt(1.0 / num_pixels * diff);
% RMSE
%% Q3b
% The optimal $\sigma_w$ is 0.88 
% 
% The RMSD for optimal $\sigma_w$ is 3.8867
%
% The RMSD for optimal $\sigma_w$ * 0.9 is 3.9041
%
% The RMSD for optimal $\sigma_w$ * 1.1 is 3.9810

%Since the images have been generated and stored in the images directory, 
%we will be directly loading the outputs and reporting them. 
%The original images can be recomputed by the code below.

first_im = load('../images/grass_first.mat');
input_im = load('../images/grass_input.mat');
output_im_sigma = load('../images/grass_sigma.mat');
output_im_large_sigma = load('../images/grass_large_sigma.mat');
output_im_small_sigma = load('../images/grass_small_sigma.mat');

first_im = double(cell2mat(struct2cell(first_im)));
input_im = double(cell2mat(struct2cell(input_im)));
output_im_sigma = double(cell2mat(struct2cell(output_im_sigma)));
output_im_large_sigma = double(cell2mat(struct2cell(output_im_large_sigma)));
output_im_small_sigma = double(cell2mat(struct2cell(output_im_small_sigma)));

% images = {'../data/grass.png'};
% im = 1;
% path = images{im};
% input_im = imread(path);
% input_im = double(input_im);
% first_im = input_im;
% rng(0);
% noise = (0.05*spread)*randn(size(input_im,1));    
% input_im = input_im + noise;
% output_im_sigma = myPatchBasedFiltering(input_im, 0.88);
% output_im_small_sigma = myPatchBasedFiltering(input_im, 0.9 * 0.88);
% output_im_large_sigma = myPatchBasedFiltering(input_im, 1.1 * 0.88);
%%
imagesc(first_im);
daspect ([1 1 1]);
title('Original Image');
colorbar;
colormap (myColorScale);
colormap gray;
%%
imagesc(input_im);
daspect ([1 1 1]);
title('Corrupted Image');
colorbar;
colormap (myColorScale);
colormap gray;
%%
imagesc(output_im_sigma);
daspect ([1 1 1]);
title('Filtered Image');
colorbar;
colormap (myColorScale);
colormap gray;
%%
%ok
% diff = output_im_small_sigma - first_im;
% diff = diff .^ 2;
% diff = sum(diff, 'all');
% num_pixels = numel(first_im);
% RMSE = sqrt(1.0 / num_pixels * diff);
% RMSE
%% Q3c
% The optimal $\sigma_w$ is 0.9
%
% The RMSD for optimal $\sigma_w$ is 3.9328
%
% The RMSD for optimal $\sigma_w$ * 0.9 is 3.9387
%
% The RMSD for optimal $\sigma_w$ * 1.1 is 4.0038

%Since the images have been generated and stored in the images directory, 
%we will be directly loading the outputs and reporting them. 
%The original images can be recomputed by the code below.

first_im = load('../images/honeycomb_first.mat');
input_im = load('../images/honeycomb_input.mat');
output_im_sigma = load('../images/honeycomb_sigma.mat');
output_im_large_sigma = load('../images/honeycomb_large_sigma.mat');
output_im_small_sigma = load('../images/honeycomb_small_sigma.mat');

first_im = double(cell2mat(struct2cell(first_im)));
input_im = double(cell2mat(struct2cell(input_im)));
output_im_sigma = double(cell2mat(struct2cell(output_im_sigma)));
output_im_large_sigma = double(cell2mat(struct2cell(output_im_large_sigma)));
output_im_small_sigma = double(cell2mat(struct2cell(output_im_small_sigma)));

% images = {'../data/honeyCombReal.png'};
% im = 1;
% path = images{im};
% input_im = imread(path);
% input_im = double(input_im);
% first_im = input_im;
% rng(0);
% noise = (0.05*spread)*randn(size(input_im,1));    
% input_im = input_im + noise;
% output_im_sigma = myPatchBasedFiltering(input_im, 0.9);
% output_im_small_sigma = myPatchBasedFiltering(input_im, 0.9 * 0.9);
% output_im_large_sigma = myPatchBasedFiltering(input_im, 1.1 * 0.9);
%%
imagesc(first_im);
daspect ([1 1 1]);
title('Original Image');
colorbar;
colormap (myColorScale);
colormap gray;
%%
imagesc(input_im);
daspect ([1 1 1]);
title('Corrupted Image');
colorbar;
colormap (myColorScale);
colormap gray;
%%
imagesc(output_im_sigma);
daspect ([1 1 1]);
title('Filtered Image');
colorbar;
colormap (myColorScale);
colormap gray;
%%
%ok
% diff = output_im_large_sigma - first_im;
% diff = diff .^ 2;
% diff = sum(diff, 'all');
% num_pixels = numel(first_im);
% RMSE = sqrt(1.0 / num_pixels * diff);
% RMSE
%% Q3d
% The intensity diagram for the isotropic gaussian patch is as follows
gaussian_patch = zeros(9,9);
gauss_normal = 0;
gaussian_sigma = 1.5;
for i = 1:9
    for j = 1:9
        exponent = ((i-5).^2 + (j-5).^2)./(2*gaussian_sigma.^2);
        to_add = exp(-exponent);
        gaussian_patch(i,j) = to_add;
        gauss_normal = gauss_normal + to_add;
    end
end

gaussian_patch = gaussian_patch / gauss_normal;
imagesc(gaussian_patch);
daspect ([1 1 1]);
title('Gaussian Mask');
colorbar;
colormap (myColorScale);
colormap gray;
##### SOURCE END #####
--></body></html>